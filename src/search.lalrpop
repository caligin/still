use crate::ast::{Search, SearchTerm, Transform, Aggregation, Sort, Comparison};

grammar;

pub Search: Box<Search<'input>> = {
    <search_terms:(SearchTerm)+> <transforms:(Transform)*> <sort:(Sort)?> => Box::new((search_terms, transforms, sort))
}

SearchTerm: SearchTerm<'input> = {
    "*" => SearchTerm::Any(), // let's say that you have to have a searchexpr but it can be "any"
    <SearchTermValue> => SearchTerm::Include(<>),
    "!" <SearchTermValue> => SearchTerm::Exclude(<>),
}

SearchTermValue = {
    <Bare>,
    <Quoted>,
    <FieldName>,
}

Bare = {
    BARE,
};

Quoted = {
    <QUOTED>, // FIXME: this is not really a quoted expr!
}

Regex = {
    <QUOTED>,
}

Transform: Transform<'input> = {
    r"\|" r"where" <field:FieldName> <comparison:FilterOp> <value:Quoted> => Transform::Filter{field, comparison, value},
    r"\|" r"parse" <field:FieldName> r"with" <parser:Regex> r"as" <bindings:FieldList>  => Transform::Parse{field, parser, bindings},
    r"\|" r"count by" <fields:FieldList> => Transform::Aggregate(Aggregation::Count(fields)),
}

FieldList: Vec<&'input str> = {
    <fields:(<FieldName> r",")*> <trailing:FieldName?> => match trailing {
        None => fields,
        Some(trailing) => {
            let mut fields = fields;
            fields.push(trailing);
            fields
        }
    }
}



Sort: Sort<'input> = {
    r"\|" r"sort by" <FieldList> => Sort::Desc(<>), // TODO: asc/desc
}

FilterOp: Comparison = {
    r"=" => Comparison::Eq,
    r"!=" => Comparison::Ne,
    r"match" => Comparison::Match,
}

FieldName = {
    FIELD_NAME,
}


match { // FIXME: is there a better way of doing this??? mostly caused by the overlap between fieldname and bare searchterm
    r#"""# ,
    r"where",
    r"!=",
    r"=",
    r"match",
    r"parse",
    r"count by",
    r"sort by",
    r"with",
    r"as",
    r",",
    r"\|",
} else {
    r#"[[:alpha:]_]+(\.[[:alpha:]_]+)*"# => FIELD_NAME,
    r#""(\\"|[^"])+""# => QUOTED,
} else {
    r#"[[:alpha:]\.-_]+"# => BARE,
} else {
    _,
}